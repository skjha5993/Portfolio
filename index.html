<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AR Vision Studio 3.0</title>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    
    <style>
        /* --- SYSTEM RESET & VARIABLES --- */
        :root {
            --glass: rgba(30, 30, 30, 0.65);
            --glass-border: rgba(255, 255, 255, 0.12);
            --accent: #0A84FF;
            --accent-glow: rgba(10, 132, 255, 0.4);
            --danger: #FF453A;
            --text: #ffffff;
            --radius: 24px;
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0; overflow: hidden; background: #000;
            font-family: 'Inter', sans-serif;
            color: var(--text);
        }

        /* --- 3D CANVAS LAYER --- */
        #ar-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: block; outline: none; z-index: 1;
        }

        /* --- UI OVERLAY LAYER --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; pointer-events: none; /* Let touches hit canvas by default */
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* --- COMMON UI STYLES --- */
        .glass-panel {
            background: var(--glass); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            pointer-events: auto; /* Re-enable clicks for UI elements */
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .icon-btn {
            background: transparent; border: none; color: rgba(255,255,255,0.7);
            width: 44px; height: 44px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; cursor: pointer; transition: all 0.2s;
        }
        .icon-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.1); }
        .icon-btn.active { color: white; background: var(--accent); box-shadow: 0 0 15px var(--accent-glow); }

        /* --- TOP HEADER --- */
        .header {
            padding: 16px 20px;
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
            pointer-events: auto;
        }
        .status-pill {
            padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 600;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.1);
            display: flex; align-items: center; gap: 6px;
        }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #ffcc00; }
        .status-dot.active { background: #32d74b; box-shadow: 0 0 8px #32d74b; }

        /* --- INSPECTOR PANEL (Bottom Sheet) --- */
        #inspector {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%) translateY(20px);
            width: 90%; max-width: 400px; padding: 20px; border-radius: var(--radius);
            display: flex; flex-direction: column; gap: 16px;
            opacity: 0; pointer-events: none;
        }
        #inspector.visible { opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: auto; }

        .inspector-row { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
        .inspector-label { font-size: 13px; color: rgba(255,255,255,0.6); font-weight: 600; }
        
        input[type=range] {
            flex-grow: 1; height: 4px; border-radius: 2px;
            background: rgba(255,255,255,0.2); appearance: none;
        }
        input[type=range]::-webkit-slider-thumb {
            appearance: none; width: 16px; height: 16px; border-radius: 50%;
            background: white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        /* Material Selector */
        .mat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; width: 100%; }
        .mat-btn {
            padding: 8px; font-size: 11px; border-radius: 12px; background: rgba(255,255,255,0.1);
            border: 1px solid transparent; color: white; cursor: pointer;
        }
        .mat-btn.active { background: var(--accent); border-color: rgba(255,255,255,0.5); }

        /* --- MAIN TOOLBAR --- */
        .toolbar-wrapper {
            padding: 30px 20px; display: flex; flex-direction: column; align-items: center; gap: 12px;
            background: linear-gradient(0deg, rgba(0,0,0,0.9) 0%, transparent 100%);
            pointer-events: none;
        }
        
        .toolbar {
            display: flex; gap: 16px; padding: 10px 24px; border-radius: 40px;
            pointer-events: auto;
        }

        /* Shape Picker (Sub-menu) */
        #shape-picker {
            display: flex; gap: 10px; padding: 8px; border-radius: 16px;
            margin-bottom: 8px; pointer-events: auto;
            transform: scale(0.9); opacity: 0; transition: all 0.2s; pointer-events: none;
        }
        #shape-picker.visible { transform: scale(1); opacity: 1; pointer-events: auto; }

        .shape-btn { width: 36px; height: 36px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); }

        /* AR Trigger Button Area */
        #ar-prompt { margin-top: 10px; pointer-events: auto; min-height: 40px; }

        /* --- NOTIFICATION --- */
        #toast {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 30px;
            font-size: 13px; opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div class="header">
            <div class="status-pill">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Ready</span>
            </div>
            <div style="display:flex; gap:10px;">
                <button class="icon-btn glass-panel" style="width:36px; height:36px; font-size:16px;" onclick="app.io.undo()" title="Undo">â†©</button>
                <button class="icon-btn glass-panel" style="width:36px; height:36px; font-size:16px;" onclick="app.io.export()" title="Save">ðŸ’¾</button>
            </div>
        </div>

        <div id="inspector" class="glass-panel">
            <div class="inspector-row">
                <span class="inspector-label">EDIT OBJECT</span>
                <button class="icon-btn" style="width:24px; height:24px; background:var(--danger); font-size:12px;" onclick="app.editor.deleteSelected()">âœ•</button>
            </div>
            
            <div class="inspector-row">
                <span class="inspector-label">Scale</span>
                <input type="range" min="0.2" max="3.0" step="0.1" id="sl-scale" oninput="app.editor.updateTransform()">
            </div>
            <div class="inspector-row">
                <span class="inspector-label">Rotate</span>
                <input type="range" min="0" max="6.28" step="0.1" id="sl-rot" oninput="app.editor.updateTransform()">
            </div>
            <div class="inspector-row">
                <span class="inspector-label">Lift</span>
                <input type="range" min="0" max="1.5" step="0.05" id="sl-y" oninput="app.editor.updateTransform()">
            </div>

            <div class="mat-grid">
                <button class="mat-btn active" onclick="app.editor.setMaterial('plastic', this)">Plastic</button>
                <button class="mat-btn" onclick="app.editor.setMaterial('metal', this)">Metal</button>
                <button class="mat-btn" onclick="app.editor.setMaterial('glow', this)">Glow</button>
            </div>
        </div>

        <div class="toolbar-wrapper">
            <div id="shape-picker" class="glass-panel">
                <button class="shape-btn" onclick="app.tools.setShape('box')">â¬œ</button>
                <button class="shape-btn" onclick="app.tools.setShape('sphere')">âšª</button>
                <button class="shape-btn" onclick="app.tools.setShape('cone')">ðŸ”º</button>
            </div>

            <div class="toolbar glass-panel">
                <button class="icon-btn active" id="tab-place" onclick="app.setMode('place')">ï¼‹</button>
                <button class="icon-btn" id="tab-select" onclick="app.setMode('select')">ðŸ‘†</button>
                <button class="icon-btn" id="tab-color" onclick="app.tools.cycleColor()">ðŸŽ¨</button>
            </div>

            <div id="ar-prompt"></div>
        </div>
    </div>

    <div id="toast">Notification</div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        /* * APP ARCHITECTURE: SINGLETON PATTERN
         * Centralizes logic to prevent state conflicts
         */
        class App {
            constructor() {
                this.state = {
                    mode: 'place', // 'place' | 'select'
                    currentShape: 'box',
                    currentColor: 0x0A84FF,
                    sessionActive: false
                };

                this.sceneMgr = new SceneManager(this);
                this.tools = new ToolManager(this);
                this.editor = new EditorManager(this);
                this.io = new IOManager(this);

                this.init();
            }

            init() {
                this.sceneMgr.init();
                this.animate();
            }

            setMode(mode) {
                this.state.mode = mode;
                this.io.updateUI(mode);
                
                // Hide inspector if leaving select mode
                if(mode !== 'select') this.editor.deselect();
                
                // Show shape picker only in place mode
                const shapePicker = document.getElementById('shape-picker');
                if(mode === 'place') shapePicker.classList.add('visible');
                else shapePicker.classList.remove('visible');
            }

            animate() {
                this.sceneMgr.renderer.setAnimationLoop((timestamp, frame) => {
                    this.sceneMgr.render(timestamp, frame);
                });
            }
        }

        /* * SCENE MANAGER: Handles Three.js, WebXR, and Rendering 
         */
        class SceneManager {
            constructor(app) {
                this.app = app;
                this.objects = [];
                this.hitTestSource = null;
                this.hitTestSourceRequested = false;
            }

            init() {
                // 1. Scene Setup
                this.scene = new THREE.Scene();

                // 2. Camera
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

                // 3. Lighting (Optimized for Realism)
                const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 3);
                hemiLight.position.set(0, 1, 0);
                this.scene.add(hemiLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
                dirLight.position.set(5, 10, 7.5);
                dirLight.castShadow = true; // Enable shadows
                dirLight.shadow.mapSize.width = 1024;
                dirLight.shadow.mapSize.height = 1024;
                this.scene.add(dirLight);

                // 4. Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.xr.enabled = true;
                this.renderer.shadowMap.enabled = true; // Enable Shadow Map
                document.body.appendChild(this.renderer.domElement);

                // 5. AR Button
                const arBtn = ARButton.createButton(this.renderer, { 
                    requiredFeatures: ['hit-test', 'dom-overlay'], 
                    domOverlay: { root: document.getElementById('ui-layer') } 
                });
                document.getElementById('ar-prompt').appendChild(arBtn);

                // 6. Controller (Raycasting Source)
                this.controller = this.renderer.xr.getController(0);
                this.controller.addEventListener('select', (e) => this.onSelect(e));
                this.scene.add(this.controller);

                // 7. Reticle (Cursor)
                this.reticle = new THREE.Mesh(
                    new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                    new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.8, transparent: true })
                );
                this.reticle.matrixAutoUpdate = false;
                this.reticle.visible = false;
                this.scene.add(this.reticle);

                // 8. Ghost Object (Preview)
                this.ghost = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: true, transparent: true, opacity: 0.3}));
                this.ghost.visible = false;
                this.scene.add(this.ghost);

                // 9. Shadow Plane (Invisible floor that catches shadows)
                const shadowPlane = new THREE.Mesh(
                    new THREE.PlaneGeometry(20, 20).rotateX(-Math.PI/2),
                    new THREE.ShadowMaterial({ opacity: 0.3 })
                );
                shadowPlane.position.y = -0.01;
                shadowPlane.receiveShadow = true;
                this.scene.add(shadowPlane);

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            onSelect(event) {
                // Determine action based on mode
                if (this.app.state.mode === 'place' && this.reticle.visible) {
                    this.app.tools.createObject();
                } else if (this.app.state.mode === 'select') {
                    this.app.editor.handleTap();
                }
            }

            render(timestamp, frame) {
                if (frame) {
                    this.handleARHitTest(frame);
                    
                    // Update Ghost
                    if(this.app.state.mode === 'place' && this.reticle.visible) {
                        this.ghost.visible = true;
                        this.ghost.position.copy(this.reticle.position);
                        this.ghost.rotation.copy(this.reticle.rotation);
                    } else {
                        this.ghost.visible = false;
                    }
                }
                this.renderer.render(this.scene, this.camera);
            }

            handleARHitTest(frame) {
                const referenceSpace = this.renderer.xr.getReferenceSpace();
                const session = this.renderer.xr.getSession();

                if (!this.hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then((refSpace) => {
                        session.requestHitTestSource({ space: refSpace }).then((source) => {
                            this.hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => { 
                        this.hitTestSourceRequested = false; 
                        this.hitTestSource = null; 
                        this.app.io.updateStatus("Ended", false);
                    });
                    this.hitTestSourceRequested = true;
                }

                if (this.hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        this.reticle.visible = true;
                        this.reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                        this.app.io.updateStatus("Surface Found", true);
                    } else {
                        this.reticle.visible = false;
                        this.app.io.updateStatus("Scanning...", false);
                    }
                }
            }
        }

        /* * TOOL MANAGER: Handles Object Creation & Factory 
         */
        class ToolManager {
            constructor(app) { this.app = app; }

            setShape(shape) {
                this.app.state.currentShape = shape;
                this.app.io.toast(`Selected: ${shape.toUpperCase()}`);
                
                // Update Ghost Geometry
                let geo;
                if(shape === 'box') geo = new THREE.BoxGeometry(0.2,0.2,0.2);
                if(shape === 'sphere') geo = new THREE.SphereGeometry(0.12,32,16);
                if(shape === 'cone') geo = new THREE.ConeGeometry(0.1,0.2,32);
                this.app.sceneMgr.ghost.geometry.dispose();
                this.app.sceneMgr.ghost.geometry = geo;
            }

            cycleColor() {
                this.app.state.currentColor = Math.random() * 0xffffff;
                this.app.io.toast("Color Changed");
                // Visual feedback on button
                document.getElementById('tab-color').style.color = '#' + this.app.state.currentColor.toString(16);
            }

            createObject() {
                const shape = this.app.state.currentShape;
                let geometry;
                
                if(shape === 'box') geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                else if(shape === 'sphere') geometry = new THREE.SphereGeometry(0.12, 32, 16);
                else if(shape === 'cone') geometry = new THREE.ConeGeometry(0.1, 0.2, 32);

                const material = new THREE.MeshStandardMaterial({ 
                    color: this.app.state.currentColor,
                    roughness: 0.1,
                    metalness: 0.1
                });

                const mesh = new THREE.Mesh(geometry, material);
                
                // Apply Transform
                this.app.sceneMgr.reticle.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);
                mesh.position.y += 0.1; // Place on top of floor
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                this.app.sceneMgr.scene.add(mesh);
                this.app.sceneMgr.objects.push(mesh);
                
                // Spawn Animation
                mesh.scale.set(0,0,0);
                this.animateScale(mesh, 1);
            }

            animateScale(mesh, target) {
                let s = 0;
                const i = setInterval(() => {
                    s += 0.1;
                    mesh.scale.set(s,s,s);
                    if(s >= target) clearInterval(i);
                }, 16);
            }
        }

        /* * EDITOR MANAGER: Handles Selection & Transformation 
         */
        class EditorManager {
            constructor(app) { 
                this.app = app; 
                this.selectedObj = null;
            }

            handleTap() {
                // 1. Get Controller Position
                const controller = this.app.sceneMgr.controller;
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld);

                // 2. Simple Proximity Check (Robust for Mobile)
                // We check which object is closest to the controller within 50cm
                let closest = null;
                let minDist = 0.5;

                this.app.sceneMgr.objects.forEach(obj => {
                    const dist = obj.position.distanceTo(controller.position);
                    if(dist < minDist) {
                        minDist = dist;
                        closest = obj;
                    }
                });

                if(closest) this.select(closest);
                else this.deselect();
            }

            select(obj) {
                this.deselect(); // Clear old
                this.selectedObj = obj;
                
                // Visual Highlight
                this.selectedObj.material.emissive.setHex(0x555555);
                
                // Open Inspector
                const inspector = document.getElementById('inspector');
                inspector.classList.add('visible');
                
                // Sync Sliders
                document.getElementById('sl-scale').value = obj.scale.x;
                document.getElementById('sl-rot').value = obj.rotation.y;
                document.getElementById('sl-y').value = obj.position.y;
            }

            deselect() {
                if(this.selectedObj) {
                    this.selectedObj.material.emissive.setHex(0x000000);
                    this.selectedObj = null;
                }
                document.getElementById('inspector').classList.remove('visible');
            }

            updateTransform() {
                if(!this.selectedObj) return;
                
                const s = parseFloat(document.getElementById('sl-scale').value);
                const r = parseFloat(document.getElementById('sl-rot').value);
                const y = parseFloat(document.getElementById('sl-y').value);

                this.selectedObj.scale.set(s,s,s);
                this.selectedObj.rotation.y = r;
                this.selectedObj.position.y = y;
            }

            deleteSelected() {
                if(this.selectedObj) {
                    this.app.sceneMgr.scene.remove(this.selectedObj);
                    // Remove from array
                    const idx = this.app.sceneMgr.objects.indexOf(this.selectedObj);
                    if(idx > -1) this.app.sceneMgr.objects.splice(idx, 1);
                    
                    this.deselect();
                    this.app.io.toast("Object Deleted");
                }
            }

            setMaterial(type, btn) {
                if(!this.selectedObj) return;
                
                // UI update
                document.querySelectorAll('.mat-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const color = this.selectedObj.material.color;
                
                if(type === 'plastic') {
                    this.selectedObj.material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0 });
                } else if(type === 'metal') {
                    this.selectedObj.material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 1.0 });
                } else if(type === 'glow') {
                    this.selectedObj.material = new THREE.MeshBasicMaterial({ color: color });
                }
                
                // Re-enable emissive for selection highlight logic to work next time
                if(type !== 'glow') this.selectedObj.material.emissive = new THREE.Color(0x555555);
            }
        }

        /* * IO MANAGER: UI Updates & Interaction Blocking 
         */
        class IOManager {
            constructor(app) { this.app = app; }

            updateStatus(text, ready) {
                const dot = document.getElementById('status-dot');
                document.getElementById('status-text').innerText = text;
                if(ready) dot.classList.add('active');
                else dot.classList.remove('active');
            }

            updateUI(mode) {
                document.querySelectorAll('.icon-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('tab-' + mode).classList.add('active');
            }

            toast(msg) {
                const t = document.getElementById('toast');
                t.innerText = msg;
                t.style.opacity = 1;
                setTimeout(() => t.style.opacity = 0, 2000);
            }

            undo() {
                const list = this.app.sceneMgr.objects;
                if(list.length > 0) {
                    const last = list.pop();
                    this.app.sceneMgr.scene.remove(last);
                    this.toast("Undo");
                }
            }

            export() {
                this.toast("Saving...");
                // Serialize logic here
                setTimeout(() => this.toast("Project Saved to Browser"), 500);
            }
        }

        // --- PREVENT GHOST CLICKS ON UI ---
        // This is CRITICAL. It stops 3D clicks when touching HTML buttons.
        document.querySelectorAll('button, input').forEach(el => {
            el.addEventListener('beforexrselect', (e) => {
                e.preventDefault();
            });
        });

        // Initialize
        window.app = new App();

    </script>
</body>
</html>
